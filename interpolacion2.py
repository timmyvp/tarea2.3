# -*- coding: utf-8 -*-
"""Untitled27.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QErjm6erxmmwRcwi_mE8Ns7m_lAmYOze
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Función original
def f(x):
    return np.sin(x) - x/2

# Interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Método de Bisección modificado para guardar iteraciones
def bisect_iterations(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")
    iterations = []
    for i in range(max_iter):
        c = (a + b) / 2
        err_est = (b - a) / 2  # Error estimado en la iteración
        iterations.append({
            "Iteración": i,
            "a": a,
            "b": b,
            "c": c,
            "Error Est": err_est,
            "P(c)": func(c)
        })
        if abs(func(c)) < tol or err_est < tol:
            return c, iterations
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2, iterations

# Selección de tres puntos equidistantes en [0,2]
x0, x1, x2 = 0.0, 1.0, 2.0
x_points = np.array([x0, x1, x2])
y_points = f(x_points)

# Construcción del polinomio interpolante de Lagrange
x_vals = np.linspace(0, 2, 100)
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals]

# Función interpolante P(x)
def P(x):
    return lagrange_interpolation(x, x_points, y_points)

# Resolver P(x)=0 usando el método de bisección en el intervalo [0,2]
root, iter_data = bisect_iterations(P, 0, 2, tol=1e-6, max_iter=100)

# Convertir la lista de iteraciones a un DataFrame para mostrar la tabla
df_iter = pd.DataFrame(iter_data)

# Gráfica de f(x) y del polinomio interpolante P(x)
plt.figure(figsize=(8, 6))
plt.plot(x_vals, f(x_vals), label="f(x) = sin(x) - x/2", linestyle='dashed', color='blue')
plt.plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f"Raíz aproximada: {root:.6f}")
plt.scatter(x_points, y_points, color='black', label="Puntos de interpolación")
plt.xlabel("x")
plt.ylabel("y")
plt.title("Interpolación de Lagrange y Bisección para P(x)=0")
plt.legend()
plt.grid(True)
plt.savefig("interpolacion_raices.png")
plt.show()

# Gráfica de convergencia: valor de c en cada iteración
plt.figure(figsize=(8, 6))
plt.plot(df_iter["Iteración"], df_iter["c"], marker='o', linestyle='-')
plt.xlabel("Iteración")
plt.ylabel("Valor de c (raíz aproximada)")
plt.title("Convergencia de la raíz en bisección")
plt.grid(True)
plt.savefig("convergencia_raiz.png")
plt.show()

# Gráfica de convergencia del error (escala logarítmica)
plt.figure(figsize=(8, 6))
plt.semilogy(df_iter["Iteración"], df_iter["Error Est"], marker='o', linestyle='-')
plt.xlabel("Iteración")
plt.ylabel("Error Estimado")
plt.title("Convergencia del error en bisección")
plt.grid(True)
plt.savefig("convergencia_error.png")
plt.show()

# Imprimir la tabla de iteraciones
print("Tabla de Iteraciones:")
print(df_iter.to_string(index=False))

print(f"\nLa raíz aproximada usando interpolación es: {root:.6f}")