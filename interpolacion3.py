# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12NhTT-XjBnWv_L3BoS_nqiq0PVHunf7G
"""

import numpy as np
import matplotlib.pyplot as plt

# Función original
def f(x):
    return np.exp(x) - x

# Interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Método de Bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        print("Advertencia: El intervalo no garantiza la existencia de una raíz. Continuando con la búsqueda...")

    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2

# Selección de cuatro puntos de interpolación
a, b = -1, 1  # Ajustar el intervalo para garantizar la existencia de una raíz
x_points = np.linspace(a, b, 4)
y_points = f(x_points)

# Construcción del polinomio interpolante
x_vals = np.linspace(a, b, 300)
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals]

# Encontrar raíz del polinomio interpolante usando bisección
root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), a, b)

# Evaluación del error en cada iteración
errors = [abs(f(x) - lagrange_interpolation(x, x_points, y_points)) for x in x_vals]

# Gráfica
plt.figure(figsize=(10, 6))
plt.plot(x_vals, f(x_vals), label="f(x) = e^x - x", linestyle='dashed', color='blue')
plt.plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f"Raíz aproximada: {root:.6f}")
plt.scatter(x_points, y_points, color='black', label="Puntos de interpolación")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.title("Interpolación de Lagrange y búsqueda de raíces")
plt.legend()
plt.grid(True)
plt.savefig("errores_interpolacion.png")
plt.show()

# Gráfica de errores
plt.figure(figsize=(8, 4))
plt.plot(x_vals, errors, label="Error absoluto", color='purple')
plt.xlabel("x")
plt.ylabel("|Error|")
plt.title("Error de interpolación de Lagrange")
plt.legend()
plt.grid(True)
plt.savefig("grafica_errores.png")
plt.show()

# Imprimir la raíz encontrada
print(f"La raíz aproximada usando interpolación es: {root:.6f}")

import numpy as np
import matplotlib.pyplot as plt

# Función original
def f(x):
    return np.exp(x) - x

# Interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Método de Bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        print("Advertencia: El intervalo no garantiza la existencia de una raíz. Continuando con la búsqueda...")

    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2

# Selección de tres puntos de interpolación
a, b = -1, 1
x_points = np.linspace(a, b, 3)
y_points = f(x_points)

# Imprimir tabla de puntos de interpolación
print("\nPuntos de Interpolación:")
print("x       | f(x)")
print("----------------")
for x, y in zip(x_points, y_points):
    print(f"{x:.6f} | {y:.6f}")

# Construcción del polinomio interpolante
x_vals = np.linspace(a, b, 300)
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals]

# Encontrar raíz del polinomio interpolante usando bisección
root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), a, b)

# Evaluación del error en cada iteración
errors = [abs(f(x) - lagrange_interpolation(x, x_points, y_points)) for x in x_vals]

# Imprimir raíz aproximada
print("\nRaíz aproximada usando interpolación y bisección:")
print(f"{root:.6f}")

# Imprimir tabla de errores
print("\nErrores en la Interpolación:")
print("x       | Error absoluto")
print("-------------------------")
for x, error in zip(x_vals[::50], errors[::50]):  # Muestra cada 50 puntos para resumir
    print(f"{x:.6f} | {error:.6e}")

# Gráfica de la función y la interpolación
plt.figure(figsize=(10, 6))
plt.plot(x_vals, f(x_vals), label="f(x) = e^x - x", linestyle='dashed', color='blue')
plt.plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f"Raíz aproximada: {root:.6f}")
plt.scatter(x_points, y_points, color='black', label="Puntos de interpolación")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.title("Interpolación de Lagrange con tres puntos y búsqueda de raíces")
plt.legend()
plt.grid(True)
plt.savefig("interpolacion_tres_puntos.png")
plt.show()

# Gráfica del error absoluto
plt.figure(figsize=(8, 4))
plt.plot(x_vals, errors, label="Error absoluto", color='purple')
plt.xlabel("x")
plt.ylabel("|Error|")
plt.title("Error de interpolación de Lagrange")
plt.legend()
plt.grid(True)
plt.savefig("grafica_error_tres_puntos.png")
plt.show()